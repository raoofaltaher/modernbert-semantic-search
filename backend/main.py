from fastapi import FastAPI, Query
from typing import List
from fastapi import FastAPI, Query, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import os
from dotenv import load_dotenv
from rapidfuzz.process import extract
import uvicorn
from sentence_transformers import SentenceTransformer
from contextlib import asynccontextmanager
from pymilvus import MilvusException # Import MilvusException
from query_engline import client

load_dotenv() # Load variables from .env file

# Configuration from environment variables
COLLECTION_NAME = os.getenv("COLLECTION_NAME", "modernbert_search")
MODEL_NAME = os.getenv("EMBEDDING_MODEL", "nomic-ai/modernbert-embed-base")
# MILVUS_URI = os.getenv("MILVUS_URI", "http://localhost:19530") # Keep commented if not used directly

# --- Lifespan Context Manager ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Load the client and environment variables are already loaded globally
    print("Application startup: Loading Milvus collection...")
    try:
        # Ensure collection exists before loading (optional but good practice)
        if not client.has_collection(COLLECTION_NAME):
             print(f"Collection {COLLECTION_NAME} not found. Please run ingest_data.py first.")
             # Decide behavior: raise error, exit, or continue without loading
             # For now, we'll print a warning and continue, search will fail later.
        else:
            client.load_collection(COLLECTION_NAME)
            print(f"Milvus collection '{COLLECTION_NAME}' loaded.")
    except MilvusException as e:
        print(f"ERROR: Failed to load Milvus collection '{COLLECTION_NAME}': {e}")
        # Optionally raise an exception here to prevent app startup if Milvus is critical
        # raise RuntimeError(f"Could not load Milvus collection: {e}") from e
    except Exception as e:
        print(f"ERROR: An unexpected error occurred during Milvus loading: {e}")
        # raise RuntimeError(f"Unexpected error during startup: {e}") from e

    yield # Application runs here

    # Clean up resources (optional)
    print("Application shutdown: Releasing Milvus collection...")
    try:
        if client.has_collection(COLLECTION_NAME): # Check again in case it was dropped
             client.release_collection(COLLECTION_NAME)
             print(f"Milvus collection '{COLLECTION_NAME}' released.")
    except MilvusException as e:
        print(f"ERROR: Failed to release Milvus collection '{COLLECTION_NAME}': {e}")
    except Exception as e:
        print(f"ERROR: An unexpected error occurred during Milvus release: {e}")
# --- End Lifespan ---


app = FastAPI(lifespan=lifespan) # Add lifespan manager to app

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load the Sentence Transformer model using the name from env var
print(f"Loading embedding model: {MODEL_NAME}")
model = SentenceTransformer(MODEL_NAME)
print("Embedding model loaded.")

# Load suggestions (consider moving this inside lifespan or a dedicated setup function)
# Also consider error handling if file not found
# Note: Loading suggestions here means it happens only once at import time.
# Moving it inside lifespan (startup) might be better if the file could change.
SUGGESTION_FILE = "indexed_titles.txt" # Use the new file generated by ingest_data.py
try:
    print(f"Loading suggestions from: {SUGGESTION_FILE}")
    with open(SUGGESTION_FILE, "r", encoding="utf-8") as f:
        all_suggestions = [line.strip() for line in f.readlines()] # Use a different variable name
    print(f"Loaded {len(all_suggestions)} suggestions.")
except FileNotFoundError:
    print(f"Warning: Suggestion file '{SUGGESTION_FILE}' not found. Suggestions disabled.")
    all_suggestions = [] # Use the different variable name

@app.get("/suggestions")
def get_suggestions(query: str = Query(..., min_length=1), max_results: int = 5):
    """
    Returns auto-suggestions based on the user's query.
    Args:
        query (str): The partial query input by the user.
        max_results (int): Maximum number of suggestions to return.
    """
    try:
        # Perform fuzzy matching using the loaded suggestions
        if not all_suggestions: # Check the correct variable
             # This case is handled by the initial load, but double-check is fine
             return {"query": query, "suggestions": []}

        matches = extract(query, all_suggestions, limit=max_results) # Use the correct variable
        suggestions = [match[0] for match in matches]
        return {"query": query, "suggestions": suggestions}
    except Exception as e:
        # Catch potential errors during fuzzy matching or list processing
        print(f"ERROR: Failed to get suggestions for query '{query}': {e}")
        # Avoid failing the request, just return empty suggestions
        # Alternatively, raise HTTPException(500, detail="Failed to process suggestions.")
        return {"query": query, "suggestions": []}



def search_papers(query, max_results=10) -> List[dict]:
    query_prefix = "search_query:"
    query_embeddings = model.encode(query_prefix + " " + query)
    # query_embeddings = model.encode(query) # Keep commented out line if desired
    try:
        result = client.search(
            collection_name=COLLECTION_NAME, # Use variable
            data=[query_embeddings],
            anns_field="dense_vector",
            limit=max_results,
            output_fields=["title", "abstract"], # Retrieve title and abstract
            search_params={"metric_type": "COSINE"}
        )
        # print(result[0]) # Debugging print
        records = [
            {
                "title": paper["entity"]["title"],
                "score": paper["distance"],
                "abstract": paper["entity"]["abstract"] # Add abstract to results
             }
            for paper in result[0]
        ]
    except MilvusException as e:
        print(f"ERROR: Milvus search error in collection '{COLLECTION_NAME}': {e}")
        # Provide a user-friendly message, potentially hiding internal details
        raise HTTPException(status_code=503, detail=f"Search service unavailable: Milvus Error Code {e.code}")
    except Exception as e:
        print(f"ERROR: Unexpected error during search: {e}")
        raise HTTPException(status_code=500, detail="Internal server error during search.")

    return records


@app.get("/search")
async def search(query: str = Query(..., min_length=1), max_results: int = 10):
    results = search_papers(query, max_results)
    return {"query": query, "results": results}




if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", reload=True, port=8050)
